---
output:
  html_document: default
  pdf_document: default
---
# Red Wine EDA
Tiago B.N. Silveira, MSc.  
July 9, 2018  

```{r echo=FALSE, message=FALSE, warning=FALSE, packages}
# Load all of the packages that you end up using in your analysis in this code
# chunk.

# Notice that the parameter "echo" was set to FALSE for this code chunk. This
# prevents the code from displaying in the knitted HTML output. You should set
# echo=FALSE for all code chunks in your file, unless it makes sense for your
# report to show the code that generated a particular plot.

# The other parameters for "message" and "warning" should also be set to FALSE
# for other code chunks once you have verified that each plot comes out as you
# want it to. This will clean up the flow of your report.

library(ggplot2)
library(dplyr)
```

```{r echo=FALSE,}
# Load the Data
wines <- read.csv("wineQualityReds.csv")
```

This project is part of the Udacity Data Analysis Nanodegree and aims to apply 
**exploratory data analysis (EDA)** techniques using R in order to explore 
relationships in one to multiple variables, as well as exploring a given dataset
for distributions, outliers, and anomalies. 

EDA can thus be understood as the numerical and graphical examination of data 
characteristics and relationships before formal, rigorous statistical analyses 
are applied. EDA can lead to insights, which may uncover to other questions, 
and eventually predictive models. As explained during the Udacity course, EDA 
is also an important “line of defense” against bad data and is an opportunity 
to notice that some assumptions or intuitions about a data set are violated.

## 1. Understanding the data
The first step before diving down EDA is to provide a short introduction into 
the dataset we are planning to explore. In this case, from a list of available
options I have choosed the "Wine Quality" dataset ([available at http://dx.doi.org/10.1016/j.dss.2009.05.016](http://dx.doi.org/10.1016/j.dss.2009.05.016)) 
since I'm a wine lover. 

Said that, and since our data is already loaded, the first thing to do is to 
take a look at the very first line of the data set:

```{r echo=FALSE, Load_the_Data}
# First look at dataset
head(wines)
str(wines)
summary(wines)
```

We already knew it is a tidy dataset. Anyway, it was possible to check there is
any missing value (NA values, for example) through the *summary* output.

To understand each data attributes, it's helpful to consult the data description
where the following information is found:
> The two datasets are related to red and white variants of the Portuguese "Vinho Verde" wine.
   For more details, consult: http://www.vinhoverde.pt/en/ or the reference [Cortez et al., 2009].
   Due to privacy and logistic issues, only physicochemical (inputs) and sensory (the output) variables 
   are available (e.g. there is no data about grape types, wine brand, wine selling price, etc.).

It's also important to notice that besides the target feature is the wine 
quality, the dataset is unbalanced regarding to it. It means there are few 
excellent or poor wines. This issue will be addressed later. For now, let's 
start taking a look at each attribute in order to understand our data in deepen
way.


## 2. Univariate Analysis
In order to catch the meaning of each variable in the dataset, in this section 
we will seek to explore each attribute in what is known as *univariate analysis*.
The most relevant attributes of this dataset are consolidated at the end of this
section. 

### A closer look at each attribute
#### Quality
Since it's the target attribute, there is any doubt about its relevance. That
way, let us first understand its distribution.

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.quality}
ggplot(aes(x=quality), data = wines) + 
    geom_histogram()
```

The first thing to notice is that there are few *really bad wines*, i.e. those
whose quality is below 3. In the same way, there are few *really good wines*, i.e. 
those whose quality is above 8. It's also effort to notice this distribution
seems like a normal one.  

Considering this is the target attribute, all the upcoming univariate analysis
will be in relation to this attribute. Due to it we need first to transform this
*int type* attribute into *factor type*:

```{r echo=TRUE, univariate.quality.factor}
## Transforming the int quality attribute into a discrete factor one:
wines$quality.factor <- factor(wines$quality)
```



#### Alcohol
This attribute refers to the percent alcohol content of the wine (% of volume).

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.alcohol}
## How the "alcohol" attribute is distributed?
ggplot(aes(x=alcohol), data = wines) + 
    geom_histogram(binwidth = 0.2)

## How the quality is related to the alcohol attribute?
ggplot(aes(x=alcohol, fill=quality.factor), data = wines) + 
    geom_histogram() + 
    scale_y_log10() + 
    facet_wrap(~ quality.factor)
```

#### Sulphates
Accordingly to the data set documentation, it refers to a wine additive which 
can contribute to sulfur dioxide gas (S02) levels. This last acts as an 
antimicrobial and antioxidant. The sulphates levels are measured by the 
concentration of *potassium sulphate* in *g/dm³*.  

To find out the range of sulphates in the evaluated wines, we can just summarize
this attribute, as follow:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulphate.summary}
summary(wines$sulphates)
```

As we did before, the next graphs show how this attribute is distributed along 
our data and how it's related to our target variable:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulphate.charts}
## How the "sulphate" attribute is distributed?
ggplot(aes(x=sulphates), data = wines) + 
    geom_histogram()

## How the quality is related to the sulphate attribute?
ggplot(aes(x=sulphates, fill=quality.factor), data = wines) + 
    geom_histogram() + 
    scale_y_log10() + 
    facet_wrap(~ quality.factor)
```

The values of this attribute are distributed around the mean and there is any 
clear correlation to the wine quality, at least at this first glance. Anyway,
the information provided by the first chart was already obtained from *summary*, 
although from the histogram it becomes clear the almost normal distribution with
right-skewed values. 

#### pH
This attribute describes how acidic or basic a wine is on a scale from 0 (very 
acidic) to 14 (very basic); most wines are between 3-4 on the pH scale.  

Again, our first step will be checking the values for this attribute using the
*summary* command, whose values around 3.31 confirm the above statement. 

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.ph.summary}
summary(wines$pH)
```

Trying to see this same information through the histogram, in order to confirm 
visually if it follows a normal distribution:  

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.ph.hist}
## How the "pH" attribute is distributed?
ggplot(aes(x=pH), data = wines) + 
    geom_histogram()
```

As a wine connoisseur, I believe the wines that are best evaluated have a higher
pH. To confirm this, I will plot again the pH distribution according to the 
quality assessment by winemakers:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.ph.histQuality}
## How the quality is related to the wine pH?
ggplot(aes(x=pH, fill=quality.factor), data = wines) + 
    geom_histogram() + 
    scale_y_log10() + 
    facet_wrap(~ quality.factor)
```

From the last chart I see I was wrong. Besides my personal taste goes for wines
not so acidic, the pH can't be directly related to the quality. 

#### Density
The wine densities vary accordingly to density of the water and on the percent
alcohol and sugar content. I particularly prefer full-bodied wines to those 
lighter ones, charactheristics I immediately associate to density. But as far as
I know, there are both strong and soft great wines, in the way I don't think 
density would be a decision attribute for wine quality. Let's check?

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.density.summary}
summary(wines$density)
```

From the summary information, the variance is about 0.01 or 1%. It means a
variation of just *1g* for each *100ml* of wine. I wonder if humans are able to
perceive such small variance, which has lead me to an interesting reference 
[[2]](#[2]) where it is said that the term "body" or "weight" of a wine, besides
is almost always a desirable aspect, is a wine property not fully defined. In
the same reference, what called my attention is that *sweetness* and the 
presence of *glycerol* can increase the perception of body, while acidity 
appears to reduce the perception of body. This description has clarified my 
misconfusion around *wine density*, in the way we now follow with the analysis:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.density.hist}
## How the "pH" attribute is distributed?
ggplot(aes(x=density), data = wines) + 
    geom_histogram()
```

Just for curiosity, I'd like to see where the mean density for each quality
category stands on the chart above. In order to do this, I should first group
the data I'm interested in (using the mean):

```{r echo=FALSE}
aggregate(wines['density'], wines['quality'], mean)
```

After calculating the density mean for each quality level, I'd like to see where 
they fall in the density histogram, as follow:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.density.histQuality}
## How the "denstiy" attribute is distributed by quality? 
## The following references have helped me to build the graph I was looking for:
## https://stackoverflow.com/questions/29957669/different-colour-palettes-for-two-different-colour-aesthetic-mappings-in-ggplot2
## https://stackoverflow.com/questions/1644661/add-a-vertical-line-with-different-intercept-for-each-panel-in-ggplot2
## https://stackoverflow.com/questions/6557977/how-do-i-add-the-mean-value-to-a-histogram-in-r
## http://www.sthda.com/english/wiki/colors-in-r
library("RColorBrewer")
ggplot(wines) +
    geom_histogram(aes(x=density)) +
    geom_vline(data = aggregate(wines['density'], wines['quality'], mean),
               mapping = aes(xintercept=density, color=as.factor(quality))) + 
    scale_color_manual(values = brewer.pal(n=8, name="Set1"))
```

Again, it's interesting to perceive how my initial idea was wrong: the wines 
assigned with higher quality have lower density in average. Let's move forward
with a similar analysis for the other attributes.


#### Sulfur dioxide
As explained in the data set description, the *sulfur dioxide* $SO_2$ can be
found in its free form, as a dissolved gas or as a bisulfite ion, or in bounded
forms with other molecules. Besides its function to prevent microbial growth and
wine oxidation, it is mostly undetectable in wine. Free concentrations over *50 
ppm*, though, turns it evident in the nose and taste of wine.  

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulfur.summary}
summary(wines[c(7,8)])
```

The summary above shows out there must be an outlier on data. Also, considering
the previous statements, I believe the quality of wine is inversely proportional
to the presence of sulfur dioxide, which I will seek to validate through the 
charts:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulfur.graphs}
## Since I want to see in an unique plot both 'free' and 'total' sulfur dioxide, 
## I tried first to make use of gridExtra library. However, I wanted to save
## space using a common legend, reason why I switched to "ggpubr" library, as
## suggested in https://stackoverflow.com/questions/13649473/add-a-common-legend-for-combined-ggplots.

#install.packages("ggpubr")
library(ggpubr)

p0 <- ggplot(data = wines) + xlim(0,120) + scale_fill_brewer(type='div')
p1 <- p0 + geom_histogram(aes(x=free.sulfur.dioxide, fill=as.factor(quality)))
p2 <- p0 + geom_histogram(aes(x= total.sulfur.dioxide, fill=as.factor(quality)))

p0log <- ggplot(data = wines) + scale_x_log10() + scale_fill_brewer(type='div')
p3 <- p0log + geom_histogram(aes(x=free.sulfur.dioxide, fill=as.factor(quality)))
p4 <- p0log + geom_histogram(aes(x= total.sulfur.dioxide, fill=as.factor(quality)))

ggarrange(p1,p3,p2,p4,
            ncol=2, nrow=2,
            common.legend = TRUE, legend = 'bottom')
```

In the chart above I intended to plot the histogram both for the free form and
the total amount of sulfur dioxide. The column on the left the histograms are 
shown in a linear x-axis, from which is clear to observe that the total amount 
follows the same shape as for the free form, with a higher number as expected.
This graphic layout, though, does not allow to compare how the sulfur dioxide is 
present considering the wine quality. For this reason, the column on the right 
shows the same data now in a logarithmic x-axis, which in turns shows this 
attribute is spread out in the same way for all quality assignments.  

Since there are some outliers, as noticed in the beggining when summarizing the 
data, I will make use of a bloxplot to check how distant it is (or they are)
from the mean:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulfur.boxplot}
## Reference for a univariate boxplot using ggplot2:
## https://stackoverflow.com/questions/25049104/why-does-a-boxplot-in-ggplot-requires-axis-x-and-y
ggplot(data = wines, aes(x='total.sulfur.dioxide', y=total.sulfur.dioxide)) + 
    geom_boxplot()
```

From the boxplot it's clear to see there are two outliers whose amount of sulfur
dioxide goes above $200 {mg}/{dm}^3$. I will back to this point later during the
multivariate analysis. 

#### Chlorides
This attribute stands for the amount of salt (*sodium chloride*) in the wine, 
measured in $g/{dm}^3$, i.e. in grams per liters. 

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.chlorides.charts}
## How the "chlorides" are present in the wines?
ggplot(data = wines) +
    geom_histogram(aes(x=chlorides, fill=as.factor(quality))) +
    scale_fill_brewer(type='div') + 
    scale_y_log10()

## In this plot I tried to check how it stands horizontally
ggplot(data = wines, aes(x='chlorides', y=chlorides)) + 
    geom_boxplot() + coord_flip()
```

From the boxplot we notice there are outliers in the right-skewed chlorides 
distribution. From the histogram, it's interesting to observe that the lowest 
and highest quality levels are around the same salt values. 


#### Residual sugar
This attribute stand for the amount of sugar remaining after fermentation stops. 
Accordingly to the dataset documentation, it's rare to find wines with less than
1 gram/liter (or $g/{dm}^3$ in the International System of Units - SI). On the
other hand, wines with more than 45 grams/liter of sugare are categorized as 
sweet.

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.acidity}
ggplot(data = wines) +
    geom_histogram(aes(x=residual.sugar, fill=as.factor(quality))) +
    scale_fill_brewer(type='div') + 
    scale_y_log10()
```

Analyzing the histogram above, even though there are some outliers, none of them
is above $45 g/{dm}^3$, which means that the whole dataset is about dry wines.

#### Acidity
There are three attributes in the dataset related to the wine acidity, all of
them measured in $g/{dm}^3$:  
* **Fixed acidity**: normally refers to *tartaric acid* which are involved with 
wine and do not evaporate readily.  
* **Volatile acidity**: the amount of acetic acid in wine, which at too high 
levels can be unpleasent, tasting like a vinegar.  
* **Citric acid**: usually found in small quantities, citric acid can add some 
*freshness* and flavor to wines. 

Considering the description above, it becomes clear the difference among the
acidities type and their impact on the wine quality. For this reason, the next 
charts plot not only a histogram for each acidity type, but also the minimum, 
maximum and mean values for each one considering only the wines assigned with a
quality level higher than 7. 

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.acidity.summary}
## Subseting the data. Instead of using "group_by", I want to summarize all the
## values whose quality is higher than 7 together:
bestAcid <- subset(wines, quality >= 7)
# best <- group_by(subset(wines, quality >= 7), quality)
acidities <- summarise(bestAcid, 
          fixed_min = min(fixed.acidity),
          fixed_mean = mean(fixed.acidity),
          fixed_max = max(fixed.acidity),
          volat_min = min(volatile.acidity),
          volat_mean = mean(volatile.acidity),
          volat_max = max(volatile.acidity),
          citric_min = min(citric.acid),
          citric_mean = mean(citric.acid),
          citric_max = max(citric.acid))
## The summarized will be highlighted in the correspondent histogram.

p0 <- ggplot(data = wines) #+ xlim(0,120) + scale_fill_brewer(type='div')
p1 <- p0 + geom_histogram(aes(x=fixed.acidity, fill=as.factor(quality))) +
    geom_vline(xintercept=acidities$fixed_min,alpha=0.7,linetype='dotted') +
    geom_vline(xintercept=acidities$fixed_mean,alpha=0.8,linetype='dotdash') +
    geom_vline(xintercept=acidities$fixed_max,alpha=0.7,linetype='dotted')
p2 <- p0 + geom_histogram(aes(x=volatile.acidity, fill=as.factor(quality))) + 
    geom_vline(xintercept=acidities$volat_min,alpha=0.7,linetype='dotted') +
    geom_vline(xintercept=acidities$volat_mean,alpha=0.8,linetype='dotdash') +
    geom_vline(xintercept=acidities$volat_max,alpha=0.7,linetype='dotted')
p3 <- p0 + geom_histogram(aes(x=citric.acid, fill=as.factor(quality))) + 
    geom_vline(xintercept=acidities$citric_min,alpha=0.7,linetype='dotted') +
    geom_vline(xintercept=acidities$citric_mean,alpha=0.8,linetype='dotdash') +
    geom_vline(xintercept=acidities$citric_max,alpha=0.7,linetype='dotted')

## Drawing text to explain the min-mean-max lines
## Reference: http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/81-ggplot2-easy-way-to-mix-multiple-graphs-on-the-same-page/
text <- paste('The dotted lines to the left and right of each histogram',
              'represent the minimum and maximum values, respectively, for the',
              'given attribute in all wines whose assigned quality is greater',
              'than or equal to 7. The centerlines represent the mean values.', 
              sep = ' ')
text.p <- ggparagraph(text = text, face = "italic", size = 8, color = "black")

## Arranging the plots on the same page
ggarrange(p1,p2,p3,text.p,
            ncol=1, nrow=4,
            common.legend = TRUE, legend = 'right')
```

The histograms above seemed reasonable to me. What called my attention, though, 
are the maximum values for the wines assigned with high quality level. Specially
when considering the *volatile acidity*, which from description is the attribute
responsible for an unpleasent tasting, I expected the maximum value to be lower.
In [[2]](#[2]) there are many discussions regarding acidity in wine, but the 
typification differs from the presented in the data description. This is an
aspect of the data that should be investigate in more detail.

### Findings from univariate analysis
In this Section I explored the *Red Wine dataset* built from a scientific 
research about whose objective was to model wine prefences by data mining from
physicochemical properties [[1]](#[1]).  

This first analysis, called univariate because it considers only one attribute 
at a time, was essential since it enabled an understanding of the subject to be 
explored, the available data, and the desired information (the relationship 
between the measured attributes and the best quality assignments). Finally, 
knowing the meaning of each attribute and its relation to the evaluated 
"phenomenon" is essential for obtaining insights and a consequent successful 
analysis.

At this point, we are already able to select some important attributes in order
to check how they relate to each other:  
  
  * The **quality** atribute will be our *targeted variable* throughout the 
  whole analysis. As a premise, this analysis objective is to find out which
  attributes are related to wines of better quality, ie, those assigned with 
  a quality level $\geq 7$.  
  
  * Considering the premise above and the findings of the univariate analysis,
  **alcohol** becomes an important feature, since it clearly separates high
  quality wines from the low quality ones.  
  
  * The **pH** and **density** attributes become relevant for a further analysis
  since they are related to the *body* sensation, as explored above.  
  
  * Some other attributes, such as **sulfur dioxide** and **chlorides**, seem 
  to be interesting in some aspect and will be explored in the multivariate 
  analysis.  
  
  * The acidity is very interesting due to its perceived sensations. Besides 
  there is no reference values for them, the outliers should be explored.  


## 3. Bivariate Analysis
In this section let's take a look at the relationships between the variables we
find out important and the previous analysis.

> **Tip**: Based on what you saw in the univariate plots, what relationships
between variables might be interesting to look at in this section? Don't limit
yourself to relationships between a main output feature and one of the
supporting variables. Try to look at relationships between supporting variables
as well.

### Alcohol Vs. Quality

```{r echo=FALSE, bivariate.alcohol-quality.scatter}
ggplot(data = wines, aes(x=alcohol, y=quality)) + 
  geom_point(alpha = 1/5, color='blue') + 
  #geom_jitter(alpha = 1/5.) + 
  geom_smooth(method = 'lm', color = 'red')
```

As it was expected to, there is some correlation between the alcohol percentage 
in the wine and its quality. However, I think this information was already 
available from the histograms in the univariate analysis. Furthermore, since
many quality levels are assigned to 11% of alcohol, relevant correlation 
among alcohol and quality arises only when we are dealing with the bordering
values.  

To check it out, I will build a radar chart with the alcohol statistics for each
one of the quality levels:

```{r bivariate.alcohol-quality.radar, message=FALSE, warning=FALSE}
## First, we need to select the appropriate data:
alcohol_quality <- wines %>%
  group_by(quality) %>%
  summarise(alcohol_mean = mean(alcohol))

## Since ggplot2 does not contain a ready function for radar chart, I choosed to
## use the radarchart function from "fmsb" package:
#install.packages('fmsb')
library(fmsb)

## In order to apply my data to radarchart, I need to transpose it before:
alcohol_quality <- as.data.frame(t(alcohol_quality))
# The code above set the dataframe name accordingly to the first dataframe row:
names(alcohol_quality) <- paste('Quality',alcohol_quality[1,], sep = '-')
# We only want the second line, ie, we need to drop the first row:
alcohol_quality <- alcohol_quality[2,]

## Now plotting the radarchart:
radarchart(fuck, axistype=1, calcex = 0.8, vlcex=0.9,
           caxislabels = c('9.6%','','11%','','12.4%'),
           title="Percentage of alcohol by quality level")
```

From the chart above it becomes really clear that the wines assigned with a 
better quality in average have higher alcohol percentages. 

### pH Vs. Density

```{r bivariate.ph-density, echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
ggplot(aes(x = pH, y = density), data = wines) + 
  geom_point(alpha = 0.35, pch = 1) + 
  geom_smooth(method = loess) + 
  facet_wrap( ~ quality) 
```



# Bivariate Analysis

> **Tip**: As before, summarize what you found in your bivariate explorations
here. Use the questions below to guide your discussion.

### Talk about some of the relationships you observed in this part of the \
investigation. How did the feature(s) of interest vary with other features in \
the dataset?

### Did you observe any interesting relationships between the other features \
(not the main feature(s) of interest)?

### What was the strongest relationship you found?


## 4. Multivariate Analaysis

> **Tip**: Now it's time to put everything together. Based on what you found in
the bivariate plots section, create a few multivariate plots to investigate
more complex interactions between variables. Make sure that the plots that you
create here are justified by the plots you explored in the previous section. If
you plan on creating any mathematical models, this is the section where you
will do that.

```{r echo=FALSE, Multivariate_Plots}

```

# Multivariate Analysis

### Talk about some of the relationships you observed in this part of the \
investigation. Were there features that strengthened each other in terms of \
looking at your feature(s) of interest?

### Were there any interesting or surprising interactions between features?

### OPTIONAL: Did you create any models with your dataset? Discuss the \
strengths and limitations of your model.

------

# Final Plots and Summary

> **Tip**: You've done a lot of exploration and have built up an understanding
of the structure of and relationships between the variables in your dataset.
Here, you will select three plots from all of your previous exploration to
present here as a summary of some of your most interesting findings. Make sure
that you have refined your selected plots for good titling, axis labels (with
units), and good aesthetic choices (e.g. color, transparency). After each plot,
make sure you justify why you chose each plot by describing what it shows.

### Plot One
```{r echo=FALSE, Plot_One}

```

### Description One


### Plot Two
```{r echo=FALSE, Plot_Two}

```

### Description Two


### Plot Three
```{r echo=FALSE, Plot_Three}

```

### Description Three

------

# Reflection

> **Tip**: Here's the final step! Reflect on the exploration you performed and
the insights you found. What were some of the struggles that you went through?
What went well? What was surprising? Make sure you include an insight into
future work that could be done with the dataset.

> **Tip**: Don't forget to remove this, and the other **Tip** sections before
saving your final work and knitting the final report!


## References
[1] P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis. 
  Modeling wine preferences by data mining from physicochemical properties.
  In Decision Support Systems, Elsevier, 47(4):547-553. ISSN: 0167-9236.  
  Available at http://dx.doi.org/10.1016/j.dss.2009.05.016
  
<a name='[2]'></a>[2] ARRUMAR. LIVRO SOBRE VINHOS.. MIT Press. http://scitechconnect.elsevier.com/wp-content/uploads/2014/06/main-38.pdf

(Ver se vou usar essa referência: https://www.jstor.org/stable/10.7312/shep17700)
