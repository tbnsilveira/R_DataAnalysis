---
output:
  html_document: default
  pdf_document: default
---
# Red Wine EDA
Tiago B.N. Silveira, MSc.  
July 15, 2018  

```{r echo=FALSE, message=FALSE, warning=FALSE, packages}
# Load all of the packages that you end up using in your analysis in this code
# chunk.

# Notice that the parameter "echo" was set to FALSE for this code chunk. This
# prevents the code from displaying in the knitted HTML output. You should set
# echo=FALSE for all code chunks in your file, unless it makes sense for your
# report to show the code that generated a particular plot.

# The other parameters for "message" and "warning" should also be set to FALSE
# for other code chunks once you have verified that each plot comes out as you
# want it to. This will clean up the flow of your report.

library(ggplot2)
library(dplyr)
library(ggpubr)
library(GGally)
```

```{r echo=FALSE,}
# Load the Data
wines <- read.csv("wineQualityReds.csv")
```

This project is part of the Udacity Data Analysis Nanodegree and aims to apply 
**exploratory data analysis (EDA)** techniques using R in order to find out
relationships in one to multiple variables, as well as exploring a given dataset
for distributions, outliers, and anomalies. 

EDA can thus be understood as the numerical and graphical examination of data 
characteristics and relationships before formal, rigorous statistical analyses 
are applied. EDA can lead to insights, which may uncover to other questions, 
and eventually predictive models. As explained during the Udacity course, EDA 
is also an important “line of defense” against bad data and is an opportunity 
to notice that some assumptions or intuitions about a dataset are violated.

## 1. Understanding the data
The first step before diving down EDA is to provide a short introduction into 
the dataset we are planning to explore. In this case, from a list of available
options I have chosen the "Wine Quality" dataset ([available at http://dx.doi.org/10.1016/j.dss.2009.05.016](http://dx.doi.org/10.1016/j.dss.2009.05.016)) 
since I'm a wine lover. 

Said that, and since our data is already loaded, the first thing to do is to 
take a look at the very first line of the dataset:

```{r echo=FALSE, Load_the_Data}
# First look at dataset
head(wines)
str(wines)
summary(wines)
```

We already knew it is a tidy dataset. Anyway, it was possible to check there is
any missing value (NA values, for example) through the *summary* output.

To understand each data attributes, it's helpful to consult the data description
where the following information is found:  

> The two datasets are related to red and white variants of the Portuguese 
"Vinho Verde" wine. For more details, consult: http://www.vinhoverde.pt/en/ or 
the reference [[1]](#[1]). Due to privacy and logistic issues, only 
physicochemical (inputs) and sensory (the output) variables are available (e.g. 
there is no data about grape types, wine brand, wine selling price, etc).  

It's also important to notice that besides the target feature is the wine 
quality, the dataset is unbalanced regarding to it. It means there are few 
excellent or poor wines. This issue will be addressed later. For now, let's 
start taking a look at each attribute in order to understand our data in deepen
way.


## 2. Univariate Analysis
In order to catch the meaning of each variable in the dataset, in this section 
we will seek to explore each attribute in what is known as *univariate 
analysis*. The most relevant attributes of this dataset are consolidated at the
end of this section.  


### A closer look at each attribute
#### Quality
Since it's the target attribute, there is any doubt about its relevance. That
way, let us first understand its distribution.

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.quality}
ggplot(aes(x=quality), data = wines) + 
    geom_histogram()
```

The first thing to notice is that there are few *really bad wines*, i.e. those
whose quality is below 3. In the same way, there are few *really good wines*, 
ie, those whose quality is above 8. It's also effort to notice this distribution
seems like a normal one.  

Considering this is the target attribute, all the upcoming univariate analysis
will be in relation to this attribute. Due to it I will first write a simple 
function to plot the histogram for a given variable, together with a boxplot
showing out the outliers.

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.function}
## Transforming the int quality attribute into a discrete factor one:
wine_attribute <- function(attribute, name = '', histScaleYlog10 = TRUE) {
  histogram <- ggplot(data = wines) +
      geom_histogram(aes(x=attribute, fill=as.factor(quality))) +
      scale_fill_brewer(type='div') + 
      labs(x = name)
  
  if (histScaleYlog10) {
    histogram <- histogram + scale_y_log10()
  }
  
  outliers <- ggplot(wines, aes(x = 1, y = attribute)) + 
      geom_jitter(alpha = 0.1 ) +
      geom_boxplot(alpha = 0.2, color = 'red') + 
      labs(x ='distance from mean')
  
  ggarrange(outliers, histogram,ncol=2, widths = c(1,2))
}
```



#### Alcohol
This attribute refers to the percent alcohol content of the wine (% of volume).

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.alcohol}
## How the "alcohol" attribute is distributed?
wine_attribute(wines$alcohol, name = 'alcohol')
```

We can notice from the boxplot there are few outliers in this attribute 
distribution, i.e. most of the samples stands inside $1.5$ times the 
interquartile rate (IQR). From the histogram, it seems to have a clear 
distinction between the alcohol distributions for each quality level. In order
to see it clearly, let's plot those histograms separately:  

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.alcohol.detail}
## How the quality is related to the alcohol attribute?
ggplot(aes(x=alcohol, fill=factor(quality)), data = wines) + 
    geom_histogram() + 
    scale_y_log10() + 
    facet_wrap(~ factor(quality))
```


#### Sulphates
Accordingly to the dataset documentation, it refers to a wine additive which 
can contribute to sulfur dioxide gas (S02) levels. This last acts as an 
antimicrobial and antioxidant. The sulphates levels are measured by the 
concentration of *potassium sulphate* in *g/dm³*.  

To find out the range of sulphates in the evaluated wines, we can just summarize
this attribute, as follow:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulphate.summary}
summary(wines$sulphates)
```

As we did before, the next graphs show how this attribute is distributed along 
our data and how it's related to our target variable:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulphate.charts}
## How the "sulphate" attribute is distributed?
wine_attribute(wines$sulphates, name = 'sulphates')
```

The values of this attribute are distributed around the mean and there is any 
clear correlation to the wine quality, at least at this first glance. Anyway,
the information provided by the first chart was already obtained from *summary*, 
although from the histogram it becomes clear the almost normal distribution with
right-skewed values. The outliers are noticeable from both charts too.  

#### pH
This attribute describes how acidic or basic a wine is on a scale from 0 (very 
acidic) to 14 (very basic); most wines are between 3-4 on the pH scale.  

Again, our first step will be checking the values for this attribute using the
*summary* command, whose values around 3.31 confirm the above statement. 

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.ph.summary}
summary(wines$pH)
```

Trying to see this same information through the histogram, in order to confirm 
visually if it follows a normal distribution:  

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.ph.hist}
## How the "pH" attribute is distributed?
wine_attribute(wines$pH, name = 'pH', histScaleYlog10 = FALSE)
```

As shows above in the plots, the wine pH follows a quasi-normal distribution. 
We can also confirm that it varies in the range of 3.0 to 3.6, also with some 
outliers beyond this range.  

In my opinion, the wines that are best evaluated have a higher pH. To validate
my supposition I will plot again the pH distribution according to the 
quality assessment by winemakers:  

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.ph.histQuality}
## How the quality is related to the wine pH?
ggplot(aes(x=pH, fill=factor(quality)), data = wines) + 
    geom_histogram() + 
    scale_y_log10() + 
    facet_wrap(~ factor(quality))
```

From the last chart I see I was wrong. Besides my personal taste goes for wines
not so acidic, the pH can't be directly related to the quality.  

#### Density
The wine densities vary accordingly to density of the water and on the percent
alcohol and sugar content. I particularly prefer full-bodied wines to those 
lighter ones, characteristics I immediately associate to density. But as far as
I know, there are both strong and soft great wines, in the way I don't think 
density would be a decision attribute for wine quality. Let's check?

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.density.summary}
summary(wines$density)
```

From the summary information, the variance is about 0.01 or 1%. It means a
variation of just *1g* for each *100ml* of wine. I wonder if humans are able to
perceive such small variance, which has lead me to an interesting reference 
[[2]](#[2]) where it is said that the term "body" or "weight" of a wine, besides
is almost always a desirable aspect, is a wine property not fully defined. In
the same reference, what called my attention is that *sweetness* and the 
presence of *glycerol* can increase the perception of body, while acidity 
appears to reduce the perception of body. This description has clarified my 
confusion around *wine density*, in the way we now follow with the analysis:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.density.hist}
## How the "density" attribute is distributed?
wine_attribute(wines$density, name = 'density', histScaleYlog10 = FALSE)
```

Just for curiosity, I'd like to see where the mean density for each quality
category stands on the chart above. In order to do this, I should first group
the data I'm interested in (using the mean):

```{r echo=FALSE}
aggregate(wines['density'], wines['quality'], mean)
```

After calculating the density mean for each quality level, I'd like to see where 
they fall in the density histogram, as follow:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.density.histQuality}
## How the "denstiy" attribute is distributed by quality? 
## The following references have helped me to build the graph I was looking for:
## https://stackoverflow.com/questions/29957669/different-colour-palettes-for-two-different-colour-aesthetic-mappings-in-ggplot2
## https://stackoverflow.com/questions/1644661/add-a-vertical-line-with-different-intercept-for-each-panel-in-ggplot2
## https://stackoverflow.com/questions/6557977/how-do-i-add-the-mean-value-to-a-histogram-in-r
## http://www.sthda.com/english/wiki/colors-in-r
library("RColorBrewer")
ggplot(wines) +
    geom_histogram(aes(x=density)) +
    geom_vline(data = aggregate(wines['density'], wines['quality'], mean),
               mapping = aes(xintercept=density, color=as.factor(quality))) + 
    scale_color_manual(values = brewer.pal(n=8, name="Set1"))
```

Again, it's interesting to perceive how my initial idea was wrong: the wines 
assigned with higher quality have lower density in average. Let's move forward
with a similar analysis for the other attributes.


#### Sulfur dioxide
As explained in the dataset description, the *sulfur dioxide* $SO_2$ can be
found in its free-form, as a dissolved gas or as a bisulfite ion, or in bounded
forms with other molecules. Besides its function to prevent microbial growth and
wine oxidation, it is mostly undetectable in wine. Free concentrations over *50 
ppm*, though, turns it evident in the nose and taste of wine.  

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulfur.summary}
summary(wines[c(7,8)])
```

The summary above shows out there must be an outlier on data. Also, considering
the previous statements, I believe the quality of wine is inversely proportional
to the presence of sulfur dioxide, which I will seek to validate through the 
charts:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulfur.graphs}
## Since I want to see in an unique plot both 'free' and 'total' sulfur dioxide, 
## I tried first to make use of gridExtra library. However, I wanted to save
## space using a common legend, reason why I switched to "ggpubr" library, as
## suggested in https://stackoverflow.com/questions/13649473/add-a-common-legend-for-combined-ggplots.

#install.packages("ggpubr")
#library(ggpubr)  ## It was already called in this first chunk.

p0 <- ggplot(data = wines) + xlim(0,120) + scale_fill_brewer(type='div')
p1 <- p0 + geom_histogram(aes(x=free.sulfur.dioxide, fill=as.factor(quality)))
p2 <- p0 + geom_histogram(aes(x= total.sulfur.dioxide, fill=as.factor(quality)))

p0log <- ggplot(data = wines) + scale_x_log10() + scale_fill_brewer(type='div')
p3 <- p0log + geom_histogram(aes(x=free.sulfur.dioxide, 
                                 fill=as.factor(quality)))
p4 <- p0log + geom_histogram(aes(x= total.sulfur.dioxide, 
                                 fill=as.factor(quality)))

ggarrange(p1,p3,p2,p4,
            ncol=2, nrow=2,
            common.legend = TRUE, legend = 'bottom')
```

In the chart above I intended to plot the histogram both for the free form and
the total amount of sulfur dioxide. The column on the left the histograms are 
shown in a linear x-axis, from which is clear to observe that the total amount 
follows the same shape as for the free form, with a higher number as expected.
This graphic layout, though, does not allow to compare how the sulfur dioxide is 
present considering the wine quality. For this reason, the column on the right 
shows the same data now in a logarithmic x-axis, which in turns shows this 
attribute is spread out in the same way for all quality assignments.  

Since there are some outliers, as noticed in the beggining when summarizing the 
data, I will make use of a bloxplot to check how distant it is (or they are)
from the mean, in the same way it was done for the previous attributes:

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sulfur.boxplot}
## Reference for a univariate boxplot using ggplot2:
## https://stackoverflow.com/questions/25049104/why-does-a-boxplot-in-ggplot-requires-axis-x-and-y
wine_attribute(wines$total.sulfur.dioxide, name = 'total.sulfur.dioxide', 
               histScaleYlog10 = FALSE)
```

From the boxplot it's clear to see there are two outliers whose amount of sulfur
dioxide goes above $200 {mg}/{dm}^3$. I will back to this point later during the
multivariate analysis. 

#### Chlorides
This attribute stands for the amount of salt (*sodium chloride*) in the wine, 
measured in $g/{dm}^3$, i.e. in grams per liters. 

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.chlorides.charts}
## How the "chlorides" are present in the wines?
wine_attribute(wines$chlorides, name = 'chlorides')
```

From the boxplot we notice there are outliers in the right-skewed chlorides 
distribution. From the histogram, it's interesting to observe that the lowest 
and highest quality levels are around the same salt values. 


#### Residual sugar
This attribute stand for the amount of sugar remaining after fermentation stops. 
Accordingly to the dataset documentation, it's rare to find wines with less than
1 gram/liter (or $g/{dm}^3$ in the International System of Units - SI). On the
other hand, wines with more than 45 grams/liter of sugar are categorized as 
sweet.

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.sugar}
wine_attribute(wines$residual.sugar, name = 'residual.sugar')
```

Analyzing the histogram above, even though there are some outliers, none of them
is above $45 g/{dm}^3$, which means that the whole dataset is about dry wines.

#### Acidity
There are three attributes in the dataset related to the wine acidity, all of
them measured in $g/{dm}^3$:  
* **Fixed acidity**: normally refers to *tartaric acid* which are involved with 
wine and do not evaporate readily.  
* **Volatile acidity**: the amount of acetic acid in wine, which at too high 
levels can be unpleasant, tasting like a vinegar.  
* **Citric acid**: usually found in small quantities, citric acid can add some 
*freshness* and flavor to wines. 

Considering the description above, it becomes clear the difference among the
acidities type and their impact on the wine quality. For this reason, the next 
charts plot not only a histogram for each acidity type, but also the minimum, 
maximum and mean values for each one considering only the wines assigned with a
quality level higher than 7. 

```{r echo=FALSE, message=FALSE, warning=FALSE, univariate.acidity.summary}
## Subseting the data. Instead of using "group_by", I want to summarize all the
## values whose quality is higher than 7 together:
bestAcid <- subset(wines, quality >= 7)
# best <- group_by(subset(wines, quality >= 7), quality)
acidities <- summarise(bestAcid, 
          fixed_min = min(fixed.acidity),
          fixed_mean = mean(fixed.acidity),
          fixed_max = max(fixed.acidity),
          volat_min = min(volatile.acidity),
          volat_mean = mean(volatile.acidity),
          volat_max = max(volatile.acidity),
          citric_min = min(citric.acid),
          citric_mean = mean(citric.acid),
          citric_max = max(citric.acid))
## The summarized will be highlighted in the correspondent histogram.

p0 <- ggplot(data = wines) #+ xlim(0,120) + scale_fill_brewer(type='div')
p1 <- p0 + geom_histogram(aes(x=fixed.acidity, fill=as.factor(quality))) +
    geom_vline(xintercept=acidities$fixed_min,alpha=0.7,linetype='dotted') +
    geom_vline(xintercept=acidities$fixed_mean,alpha=0.8,linetype='dotdash') +
    geom_vline(xintercept=acidities$fixed_max,alpha=0.7,linetype='dotted')
p2 <- p0 + geom_histogram(aes(x=volatile.acidity, fill=as.factor(quality))) + 
    geom_vline(xintercept=acidities$volat_min,alpha=0.7,linetype='dotted') +
    geom_vline(xintercept=acidities$volat_mean,alpha=0.8,linetype='dotdash') +
    geom_vline(xintercept=acidities$volat_max,alpha=0.7,linetype='dotted')
p3 <- p0 + geom_histogram(aes(x=citric.acid, fill=as.factor(quality))) + 
    geom_vline(xintercept=acidities$citric_min,alpha=0.7,linetype='dotted') +
    geom_vline(xintercept=acidities$citric_mean,alpha=0.8,linetype='dotdash') +
    geom_vline(xintercept=acidities$citric_max,alpha=0.7,linetype='dotted')

## Drawing text to explain the min-mean-max lines
## Reference: http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/81-ggplot2-easy-way-to-mix-multiple-graphs-on-the-same-page/
text <- paste('The dotted lines to the left and right of each histogram',
              'represent the minimum and maximum values, respectively, for the',
              'given attribute in all wines whose assigned quality is greater',
              'than or equal to 7. The centerlines represent the mean values.', 
              sep = ' ')
text.p <- ggparagraph(text = text, face = "italic", size = 8, color = "black")

## Arranging the plots on the same page
ggarrange(p1,p2,p3,text.p,
            ncol=1, nrow=4,
            common.legend = TRUE, legend = 'right')

### Note: I may have written a function for these plots. However, since I have
### used it only at this time, I find it faster and practical just copy/paste.
```

The histograms above seemed reasonable to me. What called my attention, though, 
are the maximum values for the wines assigned with high-quality level. 
Especially when considering the *volatile acidity*, which from description is 
the attribute responsible for an unpleasant tasting, I expected the maximum 
value to be lower. In [[2]](#[2]) there are many discussions regarding acidity 
in wine, but the typification differs from the presented in the data 
description. This is an aspect of the data that should be investigate in more
detail.

### Findings from univariate analysis
In this Section I explored the *Red Wine dataset* built from a scientific 
research about whose objective was to model wine preferences by data mining from
physicochemical properties [[1]](#[1]).  

This first analysis, called univariate because it considers only one attribute 
at a time, was essential since it enabled an understanding of the subject to be 
explored, the available data, and the desired information (the relationship 
between the measured attributes and the best quality assignments). Finally, 
knowing the meaning of each attribute and its relation to the evaluated 
"phenomenon" is essential for obtaining insights and a consequent successful 
analysis.

At this point, we are already able to select some important attributes in order
to check how they relate to each other:  
  
  * The **quality** attribute will be our *targeted variable* throughout the 
  whole analysis. As a premise, this analysis objective is to find out which
  attributes are related to wines of better quality, ie, those assigned with 
  a quality level $\geq 7$.  
  
  * Considering the premise above and the findings of the univariate analysis,
  **alcohol** becomes an important feature, since it clearly separates 
  high-quality wines from the low-quality ones.  
  
  * The **pH** and **density** attributes become relevant for a further analysis
  since they are related to the *body* sensation, as explored above.  
  
  * Some other attributes, such as **sulfur dioxide** and **chlorides**, seem 
  to be interesting in some aspect and will be explored in the multivariate 
  analysis.  
  
  * The acidity is very interesting due to its perceived sensations. Besides 
  there is no reference values for them, the outliers should be explored.  


## 3. Bivariate Analysis  
In this section we will explore the relationships among all variables in the 
dataset, directing the analysis to those that have seemed to be more relevant
from the univariate analysis. We start this by calculating the correlation 
among all the attributes: 

```{r echo=FALSE, bivariate.correlation}
## Reference: https://briatte.github.io/ggcorr/#controlling-the-main-geometry
ggcorr(wines[,2:13], geom = "blank", label = TRUE, 
       hjust = 0.9, layout.exp = 2) +
  geom_point(size = 8, aes(color = coefficient > 0, 
                           alpha = abs(coefficient) > 0.4)) +
  scale_alpha_manual(values = c("TRUE" = 0.25, "FALSE" = 0)) +
  guides(color = FALSE, alpha = FALSE)
```

From the correlation matrix we notice the only relevant attribute to quality is
the percentage of alcohol. There are some relevant correlation among other 
variables as well, but they don't contribute to the target variable that we 
are interested in. Anyway, let's keep looking deeper to this data plotting some
scatterplot pairs considering only the attributes we found relevant in the 
univariate section:  

```{r echo=FALSE, bivariate.overview}
theme_set(theme_minimal())
## Defining the variables we will explore:
variables <- c('alcohol','pH','density','chlorides',
               'volatile.acidity','quality')

## Plotting ggpairs for the selected attributed:
ggpairs(wines[variables], aes(alpha=0.3))

## I experimented adding jitter, but the result was not satisfactory:
#ggpairs(wines[variables], aes(alpha=0.3), 
#   lower = list(continuous=wrap("points", position="jitter")))
```

The pair plots above summarize all the information we have gotten until now:  
- The unbalanced distribution of quality, ie, there are more wines classified as 
5 or 6 than those below and above these values.  
- Quality is negatively correlated to the volatile acidity.  
- Quality is positively correlated to the alcohol percentage.  
- Other attributes that present some correlations are pH, density and chlorides, 
although not strong ones.  


### Alcohol Vs. Quality
In our analysis this is the relationship that seems to be the most relevant so
far. My first idea was to plot a scatter plot with a smooth line to analyze it
deeply. However, this type of visualization is not appropriate when one of the 
features on the chart is categorical or discrete, as is the case of *quality*.
A boxplot, though, brings so much more information in this case:  

```{r echo=FALSE, bivariate.alcohol-quality.boxplot}
ggplot(aes(factor(quality), alcohol), data = wines) +
  geom_jitter( alpha = .3) +
  geom_boxplot( alpha = .5,color = 'blue')+
  stat_summary(fun.y = "mean", 
               geom = "point", 
               color = "red", 
               shape = 8, 
               size = 4)
```

As it was expected to, there is some correlation between the alcohol percentage 
in the wine and its quality. However, as it's clear to see from the scattered 
points, different quality levels are assigned when the wine has 11% of alcohol. 
This leads us to afirm that relevant correlation between alcohol and quality
arises only when we are dealing with the bordering values.

Another way to check it out is building a radar chart with the alcohol 
statistics for each one of the quality levels:

```{r bivariate.alcohol-quality.radar, echo=FALSE, message=FALSE, warning=FALSE}
## First, we need to select the appropriate data:
alcohol_quality <- wines %>%
  group_by(quality) %>%
  summarise(alcohol_mean = mean(alcohol))

## Since ggplot2 does not contain a ready function for radar chart, I chose to
## use the radarchart function from "fmsb" package:
#install.packages('fmsb')
library(fmsb)

## In order to apply my data to radarchart, I need to transpose it before:
alcohol_quality <- as.data.frame(t(alcohol_quality))
# The code above set the dataframe name accordingly to the first dataframe row:
names(alcohol_quality) <- paste('Quality',alcohol_quality[1,], sep = '-')
# We only want the second line, ie, we need to drop the first row:
alcohol_quality <- alcohol_quality[2,]
# In order to use the radarchart, we need to add the minmax values as rows:
alcohol_quality=rbind(rep(12.4,6) , rep(9.6,6) , alcohol_quality)

## Now plotting the radarchart:
radarchart(alcohol_quality, axistype=1, calcex = 0.8, vlcex=0.9,
           caxislabels = c('9.6%','','11%','','12.4%'),
           title="Percentage of alcohol by quality level")
```

From the chart above it becomes really clear that the wines assigned with a 
better quality in average have higher alcohol percentages. 

### pH Vs. Density

```{r bivariate.ph-density, echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
ggplot(aes(x = pH, y = density), data = wines) + 
  geom_point(alpha = 0.35, pch = 1) + 
  geom_smooth(method = loess) + 
  facet_wrap( ~ quality) 
```

From the scatterplots above we can see a weak negative correlation between 
density and pH, ie, the higher the pH the lower the density. Beyond this there 
is no other relevant information from these graphs, since the correlation is 
somehow equivalent for all levels of quality.  

A future research may include the pH and density corresponding to the main 
hydrographic basins of the regions where the wines are produced, also 
associating these attributes with the "body" perception.


### Sulfur Dioxide Vs. Chlorides

```{r bivariate.sulfur-chlorides, echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
ggplot(aes(x = total.sulfur.dioxide, y = chlorides), data = wines) + 
  geom_point(alpha = 0.35, pch = 1) + 
  geom_smooth(method = loess) + 
  scale_x_log10() + 
  #xlim(0,100) +
  facet_wrap( ~ quality)
```

To analyse these attributes I choosed the total sulfur dioxide, since we have 
found before the free sulfur dioxide distribution has the same shape. Taking a 
look at the figure, specifically in chart 7, we can notice an outlier measure 
of sulfur dioxide around $300 mg/{dm}~3$. In order to avoid it impacting the 
charts I chose to apply the logarithm, although I could also just adjust the 
limits of the x-axis. 

Regarding the interpretation of the graph, it becomes evident that there is no 
correlation between these two variables, which was also shown on our first
correlation matrix. 


## 4. Multivariate Analysis
Most of the information we could gather from the dataset variables were already 
obtained in the previous section. From the previous analysis, **alcohol** is 
the attribute in our data most correlated to our target variable. In a lower 
rate, the *volatile.acidity* is also correlated. The next charts will try to 
explore the relationships among these three variables:  

```{r echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
ggplot(aes(x = alcohol, y = volatile.acidity, color = factor(quality)), 
       data = wines) +
      geom_point(alpha = 0.8, size = 1.2) +
      geom_smooth(method = "lm", se = FALSE,size=1.2)  +
  scale_color_brewer(type='div', guide=guide_legend(title='Quality'))
```

Previously we have found that the alcohol percentage correlation to quality 
levels is higher for bordering values. From the chart above we perceive it also
becomes true when we correlate alcohol and the volatile acidity. Our next chart 
shows the boxplot for the correlation between the volatile acidity and different
buckets of alcohol percentage, accordingly to each quality level. 

```{r echo=FALSE, fig.height=5, fig.width=8, message=FALSE, warning=FALSE}
wines$alcohol.bucket <- cut(wines$alcohol,c(8, 9, 10.5, 12, 16))

ggplot(aes(x = factor(quality), y = volatile.acidity), data = wines) + 
  geom_boxplot( aes(fill= wines$alcohol.bucket)) +
  scale_fill_brewer(type='seq',
                   guide=guide_legend(title='alcohol.bucket'))
```



### Linear regression models:
In this section I intend to build a linear regression model that could allow us 
to estimate the wine quality from the two most important attributes we have
found in our EDA.

```{r echo=FALSE, message=FALSE, warning=FALSE}
## Reference: https://github.com/nicolasfguillaume/Exploratory-Data-Analysis-with-R/blob/master/Lesson_6.md
library(scales)
library(memisc)
## use the I() operator (='as is') which inhibits interpretation/conversion of 
## objects. By protecting the expression, ensures it is interpreted in the 
## obvious arithmetical way.
m1 <- lm(I(quality) ~ I(alcohol), data = wines)
m2 <- update(m1, ~ . + volatile.acidity)
mtable(m1, m2)
```

The resultant model was not as good as I expected to, with a final R-square 
measure of 32%. Since the objective of this project was limited on EDA, I will 
not try to engineer any feature in order to reach better results, but instead I
will discuss some aspects that may explain the model insuccess: 

* **Data is unbalanced**: there are few samples of the higher and lower quality
levels. Although it's not a determinant factor in linear regression, in this 
case it may have impacted.  

* **Weak correlation**: the correlation among the attributes were weak, ie. none
of them was greater than 50%.  

* **Dependent attributes**: for a better modelling, it would be better to target
exactly what we were looking for: good wines, in the case. In this analysis we
have considered the whole spectrum for quality, with the exception of some 
analyzes in which we sub-sampled the set for quality levels greater than or 
equal to 7, but whose findings were not relevant.  

* **Subjectivity**: this is the most interesting aspect to me. Unlike a diamond 
exploratory data analysis, for example, whose measures are limited to 
physicochemical factors, the main attribute of our dataset (quality) is totally
subjective. In [[3]](#[3]), for example, the influence of the human subjectivity
on wine tasting is criticized. In addition, in our dataset it was not informed
how many distinct professionals evaluated the same wine, nor the divergences 
they may have had, as well as other important aspects that should be considered.


------

# 5. Final Plots and Summary  
### Plot One
```{r echo=FALSE, Plot_One}
## Reference on how to add the title:
## http://www.sthda.com/english/rpkgs/ggpubr/reference/annotate_figure.html
## It is not used here anymore, but I will kept the references.
ggplot(aes(x = factor(quality), y = volatile.acidity), data = wines) + 
  geom_boxplot( aes(fill= wines$alcohol.bucket)) +
  scale_fill_brewer(type='seq',
                   guide=guide_legend(title='Alcohol (%)')) + 
  labs(x ='Quality (assigned level)', y= 'Volatile acidity (g/dm³)') +
  ggtitle("Relationship between alcohol percentage, volatile acidity,
          and quality level for red wines") + 
     theme(plot.title = element_text(lineheight=.8, face="bold", hjust=-0.27))
```

### Description One
This plot does not bring the most relevant information I found in this EDA, but
it helped me to learn a lot about wine. I do appreciate drinking some wine and
I already knew acidity is an important measure. However I did not know there are
three main acidities and that one is really tasty (*citric.acid*) and the main 
aspects of grapes such as *pinot noir*. On the other hand, the volatile acidity 
is the one responsible for the vinegar unpleasant taste and one of the main 
characteristics of a bad wine.  
In the technical aspects, I choose this plot because it makes me spend a long 
time learning how to arrange all them in just one page, how to plot the 
statistics of a subset and how to describe them with a portion of text.  


### Plot Two
```{r echo=FALSE, Plot_Two}
ggpairs(wines[variables], aes(alpha=0.3), 
        title= "Pairplot with the main dataset attributes")
```

### Description Two
In my opinion, this pairplot summarises the main aspects of the dataset I have 
worked with. From the univariate analysis I was able to identify the most
relevant one and then to get an overview of the data by them. The diagonal
presents the univariate distribution and upper it we have the correlation values
among the attributes. It is the indispensable starting point for any EDA.  


### Plot Three
```{r echo=FALSE, Plot_Three}
radarchart(alcohol_quality, axistype=1, calcex = 0.8, vlcex=0.9,
           caxislabels = c('9.6%','','11%','','12.4%'),
           title="Percentage of alcohol by quality level")
```

### Description Three
I confess the radarchart was the only visualization I found harder to build with
R than with python. Even so, I spent a long time trying to find the appropriate
package and finding out how to fill its parameters. The result, however, was 
exactly what I expected: a simple chart but one with the most evident 
relationships I found out in this dataset.  

------

## Reflection
I have opted to include some reflection and discussion closer to each chart
during the EDA process. As a final reflection, I'm pretty sure R is now one 
more amazing tool I will put on my toolkit of data scientists. Before I got
enrolled in this course, and before putting my hands on dirty with this project, 
I thought someone should choose among python or R. Now I see both languages
are plenty of resources and both can be used complementarily.


## References
<a name='[1]'></a> [1] P. Cortez, A. Cerdeira, F. Almeida, T. Matos and J. Reis. 
  Modeling wine preferences by data mining from physicochemical properties.
  In Decision Support Systems, Elsevier, 47(4):547-553. ISSN: 0167-9236.  
  Available at http://dx.doi.org/10.1016/j.dss.2009.05.016
  
<a name='[2]'></a>[2] http://scitechconnect.elsevier.com/wp-content/uploads/2014/06/main-38.pdf

<a name='[3]'></a>[3] https://www.theguardian.com/lifeandstyle/2013/jun/23/wine-tasting-junk-science-analysis
